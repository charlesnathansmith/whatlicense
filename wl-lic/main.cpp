/********************************************************************************
*
* WhatLicense
* Nathan Smith
* https://github.com/charlesnathansmith/whatlicense
*
*  wl-lic
*  License generation tool
*
* Generates internally valid license key files needed by wl-extract
* See documentation for more information
*
********************************************************************************/

#include <cstdint>
#include <iostream>
#include <fstream>
#include "wl.h"

// Usage information
const char usage_msg[] =
"wl-lic [options]\n"
"Generates an internally valid registration key file needed by wl-extract\n\n"

"Run without options to create a dummy license and use with wl-extract to find a valid main_hash\n"
"Run again afterward specifying at least your HWID and the main_hash generated by wl-extract to create\n"
"a new license usable with 'wl-extract -l' to launch protected program with protections bypassed\n\n"

"Options required to generate a license for use with 'wl-extract -l' during final launch:\n\n"

"-h HWID         Hardware ID - Usually supplied in error message when trying to run protected program without a license\n"
"                Eg. : 0123-4567-89AB-CDEF-FEDC-BA98-7654-3210\n\n"

"-m main_hash	Generated by wl-extract. Will be a 151-char alphanumeric string\n\n"

"Other options. Generic values will be used if not supplied:\n\n"

"-n name         Name of registered user\n\n"

"-c company      Company of registered user\n\n"

"-x custom       Custom information that can be embedded in the license and accessed by the protected program\n"
"                Unused by WL protection mechanism, but could supply information the program author uses for additional\n"
"                custom verification\n\n"

"-d [out] license file      regkey.dat by default\n"
"-r [out] RSA file          regkey.rsa by default\n";

// RSA keys
// The specific keys used here don't matter as long as they are the correct length and the public and private keys match
// It feels insane hard-coding keys, but we're not securing anything - they're just needed to properly format the license file
// These are DER, base-36 encoded

// 2048-bit keys used for license file signature verification
const char RSA_PUBLIC_1[]  = "02820100a7039cb92a05d674622e8390826e5255a618609e95bc918d31fa0c4c531e5d49b716ae1a44e35fd90fa87235bef2741fbb63652bd1ce16569e078122d20c81eb18db50b5ca2d17f5f5ad2ba31f73cfd16365fd8b1a0c8b30feea65ff71835c18c0c447642780f90a98e8d4dc9804da655c525af2630fc3a7c9a5645fcc0294ff1b1076b6c00ea677864c60ebddb629f00c0ca5837e3cbdf1f4e3f4177cdfb2608e30bf03f4a99014af6fdc70386c9d46385af60a822ca3464b093d29ba528384b5a1ac9e23fdd3c91740e2a1adf22845905a1d18b8e993aeefbea6a5d64174643d0a4c73d38458dac6e0c5ae0993e9bbe02ce44d9c33a716e437bcc2d6ef89b90203010001";
const char RSA_PRIVATE_1[] = "02010002820100a7039cb92a05d674622e8390826e5255a618609e95bc918d31fa0c4c531e5d49b716ae1a44e35fd90fa87235bef2741fbb63652bd1ce16569e078122d20c81eb18db50b5ca2d17f5f5ad2ba31f73cfd16365fd8b1a0c8b30feea65ff71835c18c0c447642780f90a98e8d4dc9804da655c525af2630fc3a7c9a5645fcc0294ff1b1076b6c00ea677864c60ebddb629f00c0ca5837e3cbdf1f4e3f4177cdfb2608e30bf03f4a99014af6fdc70386c9d46385af60a822ca3464b093d29ba528384b5a1ac9e23fdd3c91740e2a1adf22845905a1d18b8e993aeefbea6a5d64174643d0a4c73d38458dac6e0c5ae0993e9bbe02ce44d9c33a716e437bcc2d6ef89b90203010001028201003a09814ebf11a4427153e498351b0d3582307a72e169d3d293096778a671a8cd52f868abec406f3048c6aa598eef45f738f1035944e12ed60eb860e1aec875e5329013edf841cf4fc37dd7ea29a5df13ce4cc4dcafc2a823f09197bc3ac0012300e9b43d5394f7f5fcc8fc1f641c5ba05982ace40a1492531e398135e0f90cb941f14cb4c7b8884e8721759d109522b5aba0e821775a5b2340e4a59ae99bb8a372dd3c365e88f43c06d4c279b90996ca1d2ed168b76d2f19f447dc7b972ea7ae6987deca829f9cdf1847bc9cc147a3c313ff35b56e88c5f108f9a003aa1fc97db98da2d1e58c4582aa10f58768328ab85f25ce4557e8800541d0d30aaf6bc919028180c88152c964d53b4c1c7c6ae4c4c2060711022497afc83e257450b12eb5c52fb1ca7e1b628747cf7a88aa03f57947e8847d4ee361069ae451af1efd1fcda20c80e305e53d0a04ddc1248b6037a1cdd36ed546156fea878a0fcba9aa90929b7362488b4a0d77ff42e4c5bca5461fbab5df6457dfd1b3732f57e633bbaf8ac204cb028180d53d4ca409d9157ac7c38af0eda1087927080886e9ff4bd34a98fd15f9972b4e2a744ebe6b9d0734d62ab4e86b11bbc07e954b8610832077fa1da2899ff4ccbf996f261cfcfdfaec9326f1443077d127aafa61ab5247ff930ed44b23110691475835c271c62be941b4928a056c835b59fa7e10857640ff3395a78128da365f0b02818093ee9e870a872c6dd6629177621808dc73d711ea7c7e102410326cd79ab2f6a285550f9d5d54452711e7e66dd9628d921ae5f66b22b56b193d4c6ed3652357784c878fffbe01a31f1a785eb00d085023e8e501720626a45d4d154c4bc86f3aed5bbab11348e2a39728b12b7b96736a367cd13cc87a4ed4b2549cfcafe27f8d8b0281810061d0428da46ecda98a64aa2125ff8e1174d3fc855664e2f542ecb67b140841b7134652b08a507773c721c3e630e6eb86bb09e4a0d48631a897346cd0506d4c563f1d7b102504a3cb4d1cb9e31b907a8285ad608be3ac5f11a7e5bda9922fbf0848f030075c6ddc0b65b72a549e980a99558bea2c2e385657e537f6c9347f684d028180bcf0db7abddf45a09176c3cc048a29dca23f01ee28648a0b1e40d7f620ad9d0b924bf6deda55f86125e9ff664671cca1f41fee511f4dc50db6879f8d04cb099fc4182007cce7374643cdd9d2fcaa52277fffbfaaab05c4a81d046cb4240f9e9a6c83a2150442cb500dff27274014e53cd39d133d3dbe6cdfcb6bf5887a7d1d62";

// 1024-bit keys used for license file encryption/decryption
const char RSA_PUBLIC_2[]  = "0281808d21620c096a372ecef8381ecae935c8715b5f3b7382f00e6e06eeffb38643cd5354b1c3dd481e5525eb23c3e93008674f47cc7728fa3d34243c83c15c1f0288cd7d0833adb4c1e521e63312f95e41dd760bb029e63675d229f2652f034e2dfb2eb038a1f0919f7e759ee4af357ca6765f9c955168096976eb634bdcdaad982d0203010001";
const char RSA_PRIVATE_2[] = "0201000281808d21620c096a372ecef8381ecae935c8715b5f3b7382f00e6e06eeffb38643cd5354b1c3dd481e5525eb23c3e93008674f47cc7728fa3d34243c83c15c1f0288cd7d0833adb4c1e521e63312f95e41dd760bb029e63675d229f2652f034e2dfb2eb038a1f0919f7e759ee4af357ca6765f9c955168096976eb634bdcdaad982d0203010001028180022730ba3df3320d5398ae2e80bfa713919b286c47efb19edebc84ad3fa8118fbd30e26cba6057ca1fc3cdc3618d85e0a19bd6f98dbffceab73a2473c63bd8e0dc66e8eba07c095efe6cfa30c19969a9c62ce760b85c43f0b0978ffab48468f5b486f22c11d0f41779ebd965097a130b64d4dccdc1df300975a406e5afe1b4a10240f99187df37163cbc1eb039f424ff1ee8ec7cf876e476401728f90b8b47bc10f3552d8b02f00ed7783e591bc4f19017cc9ddd4773fee40a2c15a23ece83b65ffd024090c47523d6ef4bc194a6844e1f8fee4a65482a0881bbb1e1462055f19cfca20ed9fbdd0716190f2df11e71ad258df1aca5d0cef70e2df917f70b09a1478b97f10241006883166856d45c28d79d2b17dfea6ad2563edb7a46a072a48047131b87b5ed4f49ab61dca015470c96e790268096bc30b7277485d207436f44bc061b4bb3332d024015c3c38cc0dab73c025a4a97e83cde6986f2a38725e20f2b3c3cce4f05f82171342a9e9f5b1e275f13da2ce3083b5ff341f6b3b70705b86676f8ccd8d785d031024038f4767179cb941b96f5e99aa412bb6033f1baabaeb0e0596535c1f77d5f7dc5cdc1e899640e2db4561951a51869e8f5e2a74a806b8468b53a96da6fd3c5477b";

#pragma pack(push, 1)
struct rsa_head
{
	uint8_t mod1_len, exp1_len, mod2_len, exp2_len;
};
#pragma pack(pop)

// Print generic error message
int error(const char* e)
{
	std::cerr << e << std::endl;
	return -1;
}

// Print usage error message
int usage_error(const char* e = "")
{
	std::cerr << e << "\n\n";
	std::cerr << usage_msg << std::endl;
	return -1;
}

int main(int argc, char** argv)
{
	// Defaults
	reg_info reg("Name", "Company", "Custom", "0123-4567-89AB-CDEF-FEDC-BA98-7654-3210");
	main_hash_key m;
	std::string regfile = "regkey.dat";
	std::string rsafile = "regkey.rsa";

	// Parse command line options
	// getopt isn't standard with Visual C++ unfortunately
	// Each option requires an optarg so don't have to worry about anything like '-hnc'
	// Still gives unhelpful efforts for mistakes like "-n -c company" where name optarg is omitted
	// since it thinks '-c' is the name optarg and 'company' is a spurious argument
	for (int i = 1; i < argc; i+=2)
	{
		if ((argv[i][0] == '-') && (i + 1 < argc))  // Each option must have an optarg
		{
			char *optarg = argv[i + 1];

			switch (argv[i][1])                     // Worst case this is '\0' if bare '-' supplied as an arg
			{
			// HWID
			case 'h':
				reg.hwid = optarg;
				if (!reg.sanitize_hwid())
					return usage_error("Invalid HWID");
				break;
			// main_hash
			case 'm':
				std::cout << "main_hash len: " << strlen(optarg) << std::endl;
				std::cout << "sizeof(main_hash_bin): " << sizeof(main_hash_bin) << '\n' << std::endl;

				if (!m.extract(optarg))
					return usage_error("Invalid main_hash");
				break;
			// Name
			case 'n':
				reg.name = optarg;
				break;
			// Company
			case 'c':
				reg.company = optarg;
				break;
			// Custom
			case 'x':
				reg.custom = optarg;
				break;
			// License file out
			case 'd':
				regfile = optarg;
				break;
			// RSA file out
			case 'r':
				rsafile = optarg;
				break;
			default:
				std::cerr << "Invalid option: " << argv[i];
				return usage_error();
			}
		}
		else
		{
			std::cerr << "Invalid argument: " << argv[i];
			return usage_error();
		}
	}

	// Set main_hash to arbitrary values if not supplied via command line
	if (!m.valid)
	{
		std::cout << "main_hash unspecified -- Building dummy license for use during extraction\n";
		std::cout << "Be sure to specify main_hash and HWID when building license file for launching\n" << std::endl;
		m.randomize();
	}

	std::cout << "Building license file with following details:\n\n";
	std::cout << "Name:\t\t" << reg.name << '\n';
	std::cout << "Company:\t" << reg.company << '\n';
	std::cout << "HWID:\t\t" << reg.hwid << '\n';
	std::cout << "Custom:\t\t" << reg.custom << '\n' << std::endl;

	// Attempt to write RSA public keys file
	std::ofstream rsa_file(rsafile.c_str(), std::ofstream::out | std::ofstream::binary | std::ofstream::trunc);

	if (!rsa_file.is_open())
		return error("Couldn't open RSA output file");

	rsa_public_key pubk1, pubk2;
	pubk1.import_from_base36der(RSA_PUBLIC_1);
	pubk2.import_from_base36der(RSA_PUBLIC_2);

	// Find lengths and write nfo file header
	rsa_head head;

	head.mod1_len = pubk1.n()->used;
	head.exp1_len = pubk1.exp()->used;
	head.mod2_len = pubk2.n()->used;
	head.exp2_len = pubk2.exp()->used;

	if (!rsa_file.write((char*)&head, sizeof(head)))
		return error("Error writing RSA file header");

	std::cout << std::hex;

	// Write public key digits to nfo file
	for (const mp_int& mp : { *pubk1.n(), *pubk1.exp(), *pubk2.n(), *pubk2.exp() })
		if (!rsa_file.write((char*)mp.dp, mp.used * sizeof(mp_digit)))
			return error("Error writing public keys to RSA file");

	rsa_file.close();

	// Attempt to open license file
	std::ofstream dat_file(regfile.c_str(), std::ofstream::out | std::ofstream::binary | std::ofstream::trunc);

	if (!dat_file.is_open())
		return error("Couldn't open license output file");

	// Parse RSA private keys
	rsa_private_key privk1, privk2;
	privk1.import_from_base36der(RSA_PRIVATE_1);
	privk2.import_from_base36der(RSA_PRIVATE_2);

	if (!privk1.size() || !privk2.size())
		return error("Couldn't parse RSA private keys");

	// Set up initial buffer to hold main license body and RSA signature
	size_t signed_size = lic_main_size(reg) + privk1.size();
	uint8_t *signed_lic = new uint8_t[signed_size];
	license_head *lic_head = (license_head*) signed_lic;

	// Build main license layers

	// Header
	// Core layer
	lic_build_core(lic_head->tea.core, m, reg);

	// Tea layer before TEA encryption
	lic_build_tea(lic_head->tea, reg);

	// TEA encryption
	tea_encrypt((uint32_t*) &lic_head->tea, sizeof(lic_tea), m.tea_key);

	// Password encryption
	pw_encrypt((uint32_t*) &lic_head->tea, sizeof(lic_tea), m.password.c_str());

	// Finish header
	lic_finish_head(*lic_head, m, reg);

	// Registration strings section
	size_t str_size = lic_write_strs(signed_lic + sizeof(license_head), signed_size - sizeof(license_head), reg);
	
	// Tail section
	uint8_t *tail = signed_lic + sizeof(license_head) + str_size;
	lic_build_tail(signed_lic, *((license_tail*) tail));

	// RSA signature will come immediately after the main license body
	uint8_t *sig_pos = tail + sizeof(license_tail);

	if (!rsa_sign(signed_lic, sig_pos - signed_lic, privk1, sig_pos, privk1.size()))
		return error("RSA signing failed");

	// Input blocks of size 0x7f bytes are RSA encrypted to output blocks of size 0x80
	// We need a larger output buffer to write final encrypted license to
	size_t fin_size = lic_final_size(signed_size, privk2);
	uint8_t *fin_lic = new uint8_t[fin_size];

	fin_size = lic_rsa_encrypt(signed_lic, signed_size, privk2, fin_lic, fin_size);

	if (!fin_size)
		return error("RSA encryption failed");

	if (!dat_file.write((char*)fin_lic, fin_size))
		return error("Error writing license file");

	std::cout << "License file successfully written to " << regfile << std::endl;
	std::cout << "RSA data successfully written to " << rsafile << std::endl;

	delete[] signed_lic;
	delete[] fin_lic;

	return 0;
}
